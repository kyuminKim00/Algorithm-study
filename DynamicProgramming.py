### 다이나믹 프로그래밍 ###
# 한 번 계산된 문제는 다시 계산하지 않도록 하는 알고리즘
# 큰 문제를 작게 나누고 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘
# 컴퓨터는 메모리 공간과 연산 속도에 한계가 있어 최대한 효율적으로 구현해야하지만 
# 다이나믹 프로그래밍을 통해 약간의 메모리 공간을 더 사용하면서 연산 속도를 비약적으로 상승시킬 수 있다.

# 다이나믹 프로그래밍으로 해결할 수 있는 대표적인 문제는 피보나치 수열 문제가 있다.

# 피보나치 수열의 점화식 : An+2 = An + An+1, A1 = 1, A2 = 1

# def fibo(x):
#     if x==1 or x==2:
#         return 1
#     else:
#         return fibo(x-1) + fibo(x-2)

# print(fibo(10))

# 피보나치 수열에는 큰 문제가 있는데 x가 커질 수록 연산 시간이 기하급수적으로 늘어난다. 
# 이유는 동일한 함수가 반복적으로 호출되기 때문이다. 시간 복잡도 O(2^n)

# fibo(10)을 계산하기 위해 f(5), f(4) 등이 반복적으로 호출된다. 이러한 문제를 다이나믹프로그래밍을 통해 해결한다.

# 다이나믹 프로그래밍은 다음 조건을 만족할 때 사용한다.
# 1. 큰 문제를 작은 문제로 나눌 수 있다.
# 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

# 메모리제이션 or 캐싱 : 한 번 구한 결과를 메모리 공간에 저장해두고 다시 호출하면서 사용하는 기법.

# d = [0] * 100 # 계산된 결과를 캐싱하기 위한 리스트

# def fibo(x):
#     if x==1 or x==2:
#         return 1
    
#     if d[x] != 0: # 이미 계산되어 있다면
#         return d[x] # 계산된 결과 반환
#     d[x] = fibo(x-1) + fibo(x-2) # 처음 계산하는 경우
#     return d[x]

# print(fibo(99))

# 이처럼 재귀함수를 이용하여 다이나믹 프로그래밍을 구현하는 방법은 Top-Down 방식이라고 한다. 
# 반면 반복문을 이용하여 구현하면 Bottom-Up 방식이라고 한다. 

# d = [0] * 100
# d[1] = 1
# d[2] = 1
# n = 99

# for i in range(3, n+1): # 반복문을 이용한 피보나치 수열
#     d[i] = d[i-1] + d[i-2]

# print(d[n])

# 전형적인 다이나믹 프로그래밍의 형태는 Bottom-uP 방식이다. 이 방식에서 사용되는 결과 저장용 리스트는 DP 테이블이라고 하고
# 메모리제이션은 Top-Down 방식을 부르는 표현이다.


### 실전문제2 : 1로 만들기 ###

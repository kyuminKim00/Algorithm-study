### DFS/BFS ###
# 그래프를 탐색하기 위한 대표적인 두 가지 알고리즘

## DFS ##
# Depth-First Search, 깊이 우선 탐색, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
# 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘, 스택 자료구조를 이용

# 동작 과정
# 1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
# 2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
# 3. 2의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
# 방문처리 : 스택에 한 번 삽이되어 처리된 노드가 다시 삽입되지 않게 체크하는 것.

# def dfs(graph, v, visited):
#     visited[v] = True # 현재 노드를 방문 처리
#     print(v, end=' ')

#     for i in graph[v]:
#         if not visited[i]:
#             dfs(graph, i, visited)

# graph = [ # 인접리스트로 그래프 표현
#     [],
#     [2, 3, 8],
#     [1, 7],
#     [1, 4, 5],
#     [3, 5],
#     [3, 4],
#     [7],
#     [2, 6, 8],
#     [1, 7]
# ]

# visited = [False] * 9 # 노드가 방문된 정보를 1차원 리스트로 표현

# dfs(graph, 1, visited)


## BFS ##
# Breadth First Search, 너비 우선 탐색, 가까운 노드부터 탐색하는 알고리즘
# BFS 구현은 큐 자료구조를 이용한다. 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 구현하면 자연스럽게 먼저 들어온 것이 먼제 나가게 되어, 가까운 노드부터 탐색을 진행하게 된다.

# 동작 과정
# 1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
# 2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 한다.
# 3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

# BFS는 O(N)의 시간이 소요되고 일반적으로 DFS보다 수행 시간이 짧다.

# from collections import deque

# def bfs(graph, start, visited): 
#     queue = deque([start]) # deque 객체를 만들고 start 노드 넣기 
#     visited[start] = True
#     while queue:

#         v = queue.popleft() # 가장 먼저 들어온 노드 pop
#         print(v, end=' ')
#         for i in graph[v]: # 노드에 인접한 노드 순회
#             if not visited[i]: 
#                 queue.append(i) # 아직 방문하지 않은 노드면 큐에 append
#                 visited[i] = True

# graph = [ # 인접리스트로 그래프 표현
#     [],
#     [2, 3, 8],
#     [1, 7],
#     [1, 4, 5],
#     [3, 5],
#     [3, 4],
#     [7],
#     [2, 6, 8],
#     [1, 7]
# ]

# visited = [False] * 9
# bfs(graph, 1, visited)

## 실전문제3 : 음료수 얼려 먹기 ##
# NxM 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다. 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다.
# 이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오.